---
title: "islfd"
output:
  ioslides_presentation:
    widescreen: yes
  beamer_presentation: default
  slidy_presentation: default
---

## Plan

- R Programming
- Probabilidad y Estadística (crash course)
- Aprendizaje Estadístico
- Ejemplo práctico

## R Programming

- Propósito y Task Views
- Instalación de paquetes
- Ayuda
- Tipos de datos
- Tipos de objeto
- Operaciones básicas
- Estructuras de control
- Environments
- Vectorización, funciones anónimas
- Paquetes útiles
- Graficación: ggplot2

## Propósito y Task Views

R es un lenguaje creado para hacer cómputo estadístico y graficación. Ha sido
ampliamente adoptado y extendido por miembros de la comunidad científica, y tiene
performance comparable a MATLAB o GNU Octave en cuanto a cómputo con matrices.

La más grande ventaja de R es el acceso a cientos de paquetes a través del 
[CRAN](https://cran.r-project.org/), con mirrors alrededor del mundo. El CRAN 
define y mantiene Task Views, listas de paquetes con un propósito en común. 
También mantiene versiones binarias de muchos paquetes para Windows y OS X.

## Algunas Task Views

- Bayesian Inference
- Clinical Trial Design, Monitoring and Analysis
- Econometrics
- Analysis of Ecological and Environmental Data
- Empirical Finance
- Statistical Genetics
- Natural Language Processing
- Machine Learning & Statistical Learning
- Analysis of Spatial Data
- Graphical Models

[Full list](https://cran.r-project.org/web/views/)

## Instalación de paquetes
Para instalar paquetes del CRAN
```{r, eval=FALSE}
install.packages("dplyr")
install.packages("file:///tmp/dplyr.tgz", repos=NULL)
```

Si no hay una versión binaria disponible, `install.packages` compilará las fuentes
indicadas, también se encarga de resolver dependencias de paquetes.

Para instalar todos los paquetes en un task view
```{r, eval=FALSE}
install.packages("ctv")
library("ctv")
install.views("NaturalLanguageProcessing")
```


## Instalación de paquetes
El paquete `devtools` nos permite instalar un paquete directamente desde su
fuente en github, bitbucket, svn, etc.

```{r, eval=FALSE}
install.packages("devtools")
library("devtools")
install_github("hadley/ggplot2")
```

El IDE RStudio ofrece una manera sencilla de realizar estas instalaciones, además
de ofrecer integración con `packrat`, un paquete que permite aislar el ambiente
de R usando una biblioteca privada de paquetes (similar a `virtualenv`).

## Ayuda

R ofrece una manera de acceder a la documentación de una función a través de 
`?`. Es común que las funciones que un paquete expone estén documentadas, así como
encontrar documentación de un paquete en general

```{r, eval=F}
?library
?devtools
```

También podemos obtener ayuda acerca de un operador

```{r, eval=F}
?`+`
```

## Ayuda

Además, algunos paquetes con funcionalidad compleja ofrecen vignettes,
con quickstarts o tutoriales acerca de su uso

```{r, eval=F}
vignette(package = "dplyr")
vignette("databases", package = "dplyr")
```

Si todo lo demás falla, existe una comunidad activa en [stack overflow](http://stackoverflow.com/tags/r)
para todo lo relacionado con R como lenguaje, así como [cross validated](http://stats.stackexchange.com/) para 
todas las preguntas de índole estadística.

## Tipos de datos

Existen 6 tipos de datos "atómicos" en R

```{r}
class(TRUE)
class(42)
class(42L)
```

## Tipos de datos

Existen 6 tipos de datos "atómicos" en R

```{r}
class(4 + 2i)
class("42")
class(charToRaw("B"))
```

## Tipos de datos

Adicionalmente, un factor puede ser usado para expresar variables categóricas.
Un factor puede ser ordenado.

```{r}
class(factor(1))
```

## Tipos de datos

`NULL` representa al objeto nulo. Indica que un valor o función no está definida

```{r}
is.null(NULL)
is.null(NA)
1 == NULL
```

## Tipos de datos

`NA` representa datos faltantes, es una constante de longitud 1. `NA` puede ser
cualquier tipo de dato excepto `raw`. `NA` no es `NULL`, y existen comportamientos
predefinidos para lidiar con datos faltantes.

```{r, error = T}
NA + 1
sum(c(1, 2, 3, NA), na.rm = TRUE)
na.fail(c(1, 2, 3, NA))
```

## Tipos de objeto

Existen muchos tipos de objeto en R, y dos maneras comunes de definir tipos de
objeto (clases S3 y S4). Sin embargo, los tipos más comunes son vectores, listas, 
matrices y data frames.

No existe el tipo de objeto "escalar" en R, el dato atómico es el vector.
```{r}
length(1)
```

## Vectores

Un vector sólo puede contener un tipo de dato. Si un elemento de otro tipo se
concatena a un vector, el vector resultante es del tipo más general. La manera
más fácil de construir vectores es a través de `c`

```{r}
c(TRUE, FALSE)
c(TRUE, FALSE, 2)
c(TRUE, FALSE, 2, "")
```

## Vectores

Se puede acceder de manera posicional a los elementos de un vector
```{r}
v <- 10:13
v[[1]]
v[c(1:2)]
```

## Vectores

Los elementos de un vector pueden ser nombrados y también accedidos de ese modo
```{r}
names(v) <- c("uno", "dos", "tres")
v[["uno"]]
```

## Listas

Una lista puede contener cualquier tipo de objeto y combinar distintos tipos
de datos.
```{r}
l <- list(1, TRUE, "...")
l
```

## Listas

Al igual que un vector, se puede acceder de manera posicional o a través de 
nombre. A diferencia de un vector, se puede acceder usando el operador `$`
```{r}
names(l) <- c("uno", "true", "ellipsis")
l$uno
```

## Listas

Se pueden borrar elementos de una lista refiriendolos a `NULL`
```{r}
l$true <- NULL
l
```

## Matrices

Una matriz es como un vector, aunque con dos dimensiones. Las matrices se llenan
y se despliegan en orden de columnas.
```{r}
m <- matrix(c(1,2,3,4), nrow = 2)
m
m[1, 2]
```
Al igual que un vector, sólo pueden contener un tipo de dato

## Matrices

Las columnas y las filas se pueden nombrar por separado
```{r}
colnames(m) <- c("col1", "col2")
rownames(m) <- c("row1", "row2")
m
m["row1", "col1"]
```

## Matrices
`dim`, `nrow` y `ncol` nos dan las dimensiones de una matriz
```{r}
dim(m)
nrow(m)
ncol(m)
```

## Data Frames

Un data frame es una colección de variables, que se comporta como matriz
o como lista de columnas, según la función que se le aplique.
```{r}
df <- data.frame(col1 = c(1,2), col2 = c("tres","cuatro"))
df
```
Un data frame puede contener distintos tipos de datos

## Data Frames
```{r}
dim(df)
df$col1
names(df)
```

## Factores
Un tipo de objeto adicional es el factor, que sirve para representar variables
categóricas, ordenadas o no
```{r}
f <- factor(c("A veces", "Siempre", "A veces", "Nunca"), 
            levels = c("Nunca", "A veces", "Siempre"))
f
as.ordered(f)
```

## Factores
```{r}
nms <- c("John", "Paul", "George", "Ringo")
df <- data.frame(nombre=nms, sexo=f, stringsAsFactors = F)
df
summary(df)
```

## Operaciones básicas
```{r}
7 + 2
7 - 2
7 * 2
```

## Operaciones básicas
```{r}
7 / 2
7 %% 2
7 %/% 2
```

## Operaciones básicas
```{r}
7 / 2
7 ^ 2
7 ** 2
```

## Operaciones básicas
```{r}
7 %/% 2
7 %% 2
```

## Operaciones básicas
```{r}
TRUE & FALSE
TRUE | FALSE
!TRUE
```

## Operaciones básicas
Todas estas operaciones se pueden aplicar a vectores, y se aplicarán componente
a componente, repitiendo el vector más pequeño como sea necesario
```{r}
c(1, 2) + c(3, 0)
c(2, 1) * c(2, 2)
c(1, 2, 3, 4) ^ c(2, 3)
```

## Estructuras de control
`if`, `else`, `for`, `while`, `break`, `next` funcionan como en otros
lenguajes.
```{r}
for(i in 1:5) {
  if(i < 3) {
    print(i)
  } else {
    print(6 - i)
  }
}
```


## Funciones
Para definir una función
```{r}
do.something <- function(x, y) {
  x + y
}
do.something(10, 3)
```

## Funciones
Valores por defecto en argumentos
```{r}
do.something <- function(x, y=1) {
  x + y
}
do.something(10)
do.something(y=3, 10)
```

## Funciones
Argumentos adicionales, no definidos
```{r}
do.something <- function(x, y=1, ...) {
  x + y + sum(...)
}
do.something(10, z=3, a=5)
```
`...` sólo puede ser usado como argumento de una función

## Funciones
`do.call` llama la función especificada con una lista de argumentos
```{r}
args <- list(x=4, y=3, z=1)
do.call(do.something, args)
do.call("do.something", args)
```

## Environments
Un environment es un espacio de nombres, usado en las reglas de scoping de R. 
(Scope léxico) También se pueden crear manualmente.
```{r}
e <- new.env()
e$a <- FALSE
e$b <- "b"
e$uno <- 1
ls(e)
```

## Environments
Un environment se comporta de manera similar a una lista, pero difiere de varias formas importantes.
No se puede acceder posicionalmente a nombres de un environment. Los environments
no están ordenados
```{r, error=T}
l[[1]]
e[[1]]
```

## Environments
Una lista puede contener varios elementos con el mismo nombre, aunque esto no es recomendado
```{r}
list(a="a", a="b")
e$a <- "b"
e$a
```

## Environments
Un environment tiene un "padre". Solo el environment vacío no tiene un padre.
```{r}
parent.env(e)
parent.env(globalenv())
```

## Environments
Asignar un elemento de una lista a `NULL` lo elimina de la lista. Hacerlo en un
environment crea una referencia a `NULL`.
```{r}
e$a <- NULL
ls(e)
```

## Environments
`search()` regresa la lista de padres del environment global, este es el orden 
en el que se resuelven los nombres
```{r}
search()
pryr::where("var")
```

## Environments
Cuando se carga un paquete nuevo, se agrega a `search()` entre el `globalenv()` y
el siguiente elemento
```{r}
search()
library(pryr)
search()
```

## Environments
Para checar si un nombre existe en un environment se usa `exists`. Por defecto
se busca en todos los padres, para evitarlo usamos `inherits = FALSE`
```{r}
exists("mean", envir=e)
exists("mean", inherits=F)
```

## Environments
Una función tiene cuatro environments asociados. El enclosing, que es el
environment donde fue creada la función, se usa para el scoping. Todos los
objetos a los que haga referencia la función se buscaran primero en este
environment.
```{r}
environment(sd)
```

## Environments
Un binding environment es donde existe un nombre que haga referencia a la función,
una función puede tener más de un binding environment
```{r}
sd <- stats::sd
pryr::where("sd")
```

## Environments
Estos dos environments pueden ser distintos, y sólo el primero se usa para las
reglas de scoping, asegurando que la función siempre busque las referencias adecuadas
```{r}
var <- "Can't break this"
pryr::where("var")
sd(c(1, 2, 3))
environment(sd)
pryr::where("sd")
```

## Environments
El environment de ejecución es efímero, se crea al ejecutar una función, y se
destruye al terminar la misma, a menos de que la función regrese a su vez una 
función
```{r}
plus <- function(x) {
  function(y) x + y
}
plus.1 <- plus(1)
environment(plus.1)
identical(parent.env(environment(plus.1)), environment(plus))
```

## Environment
El último environment asociado a una función es el de llamada. Este se puede
acceder a través de `parent.frame`, típicamente no será necesario acceder a él,
a menos de que se quiera usar evaluación no estándar o simular un scoping dinámico
```{r}
f <- function() {
  x <- 10
  function() {
    print(get("x", environment()))
    print(get("x", parent.frame()))
  }
}
x <- 5
f()()
```

## Attach, Detach
`attach` añade un objeto a `search()`. Este objeto puede ser un environment,
lista o data frame, permitiendo acceso a su lista de nombres en el environment
en el que se esta trabajando.
```{r}
attach(e)
search()
detach(e)
```

## Attach, Detach
`library` funciona como `attach`, para quitar un paquete podemos usar `detach`
```{r}
library(pryr)
detach("package:pryr", unload=T)
search()
```

## Vectorización
Muchas funciones base en R incluyen llamadas a `.Internal`, `.Primitive` o `.Call`
```{r}
sum
paste
```

## Vectorización
Estas funciones de hecho son llamadas a rutinas de C o Fortran, por razones de
velocidad. Esto a menudo quiere decir que es más rápido llamar una función 
predefinida que replicarla
```{r}
for.sum <- function(m) {
  s <- 0
  for(i in v) s <- s + i
  s
}
```

## Vectorización
```{r}
v <- matrix(rbinom(1e6, 100, 0.5), ncol = 1e3)
system.time(rep(for.sum(v), 1e6))
system.time(sum(v, 1e6))
```

Para reducir el overhead de llamar repetidamente las funciones de C, es útil 
pensar en aritmética de vectores y en utilizar funciones primitivas, en lugar
de escribir ciclos `for`. Esto es especialmente un problema si R tiene que cambiar
el tamaño de un objeto en cada paso del ciclo

## Vectorización
Otra manera de "vectorizar" es utilizar funciones de la familia `apply`. En este
caso no siempre se están reduciendo las llamadas a funciones internas, pero se está asegurando
que no haya efectos secundarios y el código se vuelve más leíble
```{r}
apply(v, MARGIN=2, FUN=mean)[1:5]
```

## Vectorización
```{r}
m <- nrow(v)
n <- ncol(v)
means <- rep(0, n)
for(j in 1:n) {
  col.sum <- 0
  for(i in 1:m) {
    col.sum <- col.sum + v[i, j]
  }
  means[j] <- col.sum/m
}
means[1:5]
```

## Vectorización
Por último, si la función a aplicar a una secuencia se va a utilizar sólo una vez, 
y es fácil de leer, se puede utilizar una función anónima.
```{r}
apply(v, MARGIN=2, FUN=function(col) quantile(col, 0.3) )[1:5]
```

## Paquetes útiles
Hay paquetes que mejoran algunos aspectos de R en general, y ayudan a evitar
algunas deficiencias de la sintáxis. Todos los paquetes que incluyo en esta
sección están en el CRAN.

## Magrittr
Magrittr añade un operador con funcionalidad de pipe
```{r}
library(magrittr)
3 %>% sum(1) %>% prod(2) 
prod(2, sum(1, 3))
```

## Magrittr
```{r}
data.frame(a=rnorm(5, 5, 1), b=runif(5)) %>%
  scale() %>%
  summary()
```

## Magrittr
Añade también otros operadores con funcionalidad similar pero resultado
distinto, por ejemplo, `%<>%` funciona como `%>%` pero actualiza el nombre en 
el lado izquierdo con el resultado de la expresión, ver `?magrittr` para más
detalles.

## Lubridate, Zoo
`lubridate` y `zoo` añaden mejor soporte para fechas. Aunque R incluye
soporte para fechas, estos paquetes lo mejoran.
```{r, message=F}
library(zoo)
library(lubridate)
interval(as.Date("2016-01-01"), Sys.Date()) / months(1)
as.Date("2016-01-31") %m+% months(0:4)
as.yearmon(Sys.Date()) 
```

## Lubridate, Zoo
`yearmon` además puede ser operado como numérico, con el entero representando
un año completo
```{r}
as.yearmon(Sys.Date()) + 1/12
as.Date("2016-01-31") %m+% months(0:4) %>% as.yearmon() + 1
```

## Pryr
`pryr` incluye algunas funciones para lidiar con los componentes internos de R
(como `where`). De sus funciones más útiles es partial
```{r, message=FALSE}
library(pryr)
my.mean <- partial(mean, na.rm=T)
my.mean(c(1, 2, 3, NA, 4))
```

## Jsonlite
`jsonlite` añade la capacidad de leer y serializar JSON a partir de objetos de 
R. 
```{r}
library(jsonlite)
j <- '[{"a": 1, "b": 2, "c": "A"}, {"a": 4, "b": 1, "c": "B"}]'
d <- fromJSON(txt = j)
d
toJSON(d)
```

## Dplyr
`dplyr` añade muchas funciones para manipulación de datos a través de data frames,
con un gran performance y backends para varias bases de datos. Nos permite
manipular directamente tablas de una BD, sin escribir SQL, toda la evaluación
es lazy y, de ser posible, se realiza directamente en la BD.

Para estos ejemplos utilizaremos un data frame local. Para saber más de como 
usar `dplyr` con bases de datos, revisar `vignette("databases", package="dplyr")`

## Dplyr
```{r, message = F}
library(dplyr)
mtc <- tbl_df(mtcars)
mtc$car <- row.names(mtcars)
head(mtc)
```

## Dplyr | Select
```{r}
mtc %>% select(car, cyl, mpg) %>%
  head()
```

## Dplyr | Filter
```{r}
mtc %>% select(car, cyl, mpg) %>%
  filter(cyl >= 6) %>%
  head()
```

## Dplyr | Arrange
```{r}
mtc %>% select(car, cyl, mpg) %>%
  filter(cyl >= 6) %>%
  arrange(desc(mpg)) %>%
  head()
```

## Dplyr | Mutate
```{r}
mtc %>% select(car, cyl, mpg) %>%
  filter(cyl >= 6) %>%
  arrange(desc(mpg)) %>%
  mutate(kpl = 1.6/3.78*mpg) %>%
  head()
```

## Dplyr | Group by + Summarise
```{r}
mtc %>% 
  select(car, cyl, mpg) %>%
  filter(cyl >= 6) %>%
  arrange(desc(mpg)) %>%
  mutate(kpl = 1.6/3.78*mpg) %>%
  group_by(cyl) %>%
  summarise(mean.kpl = mean(kpl), n = n())
```

## Dplyr | Join
```{r}
cyls <- mtc %>% select(car, cyl) %>% sample_n(20)
mpgs <- mtc %>% select(car, mpg) %>% sample_n(20)
inner_join(mpgs, cyls) %>% head()
```

## Dplyr 
Las operaciones que se realizan después de `group_by` se aplican a cada grupo
por separado. e.g. `arrange` organiza las filas adentro de cada grupo por las 
columnas indicadas. 

Existen versiones de todos estos verbos que toman cadenas de caracteres en lugar 
de nombres para indicar las columnas, simplemente hay que agregar un _ (`select_` ,
`mutate_`, etc).

Para una introducción más extensa ver `vignette("introduction", package="dplyr")`

## Ggplot2
`ggplot2` es un sistema de graficación, basado en gramática de gráficas. Los 
componentes de una gráfica se pueden "sumar" unos a otros, causando overlay de capas 
o modificaciones, según corresponda

## Ggplot2 | Scatter
```{r, fig.height=4}
library(ggplot2)
ggplot(mtc, aes(x=mpg, y=disp)) + geom_point()
```

## Ggplot2 | Color aesthetic
```{r, fig.height=4}
ggplot(mtc, aes(x=mpg, y=disp, color=as.factor(cyl))) + geom_point()
```

## Ggplot2 | Smooth curve (loess)
```{r, fig.height=4}
ggplot(mtc, aes(x=mpg, y=disp)) + geom_point() + geom_smooth()
```

## Ggplot2 | Histogram + Density
```{r, fig.height=4, message=F}
ggplot(mtc, aes(x=mpg, y=..density..)) + geom_histogram() + geom_density()
```

## Ggplot2 | Bar (counts)
```{r, fig.height=4}
ggplot(mtc, aes(x=as.factor(cyl))) + geom_bar()
```

## Ggplot2 | Boxplot 
```{r, fig.height=4}
ggplot(mtc, aes(x=as.factor(cyl), y=mpg)) + geom_boxplot()
```

## Ggplot2 | Facet wrap
```{r, fig.height=4}
ggplot(mtc, aes(x=disp, y=mpg)) + geom_point() + facet_wrap(~cyl, scales="free")
```

## Ggplot2 | Contour
`ggplot2` también permite controlar leyendas, etiquetas, ejes, etc. Para más 
detalles ver la [documentación](http://docs.ggplot2.org/current/)

## Probabilidad y Estadística

- Distribución de probabilidad
- La distribución normal
- Ley de los grandes números. Implicaciones
- Teorema central de límite. Implicaciones
- Conclusiones de Teoría de la Decisión
- Estimación de parámetros
- Modelo líneal
- Valores p, R^2
- Interpretaciones de la teoría
- Ejemplos de distribuciones
- Data Science vs Estadística

## Distribución de Probabilidad
Dado un experimento aleatorio con posibles resultados conocidos, 
una *ley* o *distribución* de probabilidad describe la verosimilitud de cada
resultado, asignándole una medida. Los posibles resultados del
experimento son codificados en una *variable aleatoria*. El conjunto de 
posibles valores de dicha variable se conoce como el *soporte* de la distribución.

Si la variable aleatoria es *discreta*, es decir, si toma valores en un conjunto 
finito o infinito numerable, la distribución se caracteriza por una función *masa de probabilidad*. 
Si la variable aleatoria es *continua*, se catacteriza por una
función de *densidad de probabilidad*.

## Distribución de Probabilidad | Distribución Discreta
El resultado de evaluar la función masa en un punto del soporte es
igual a la probabilidad de que la variable tome ese valor (f(x) = Pr(X=x)), además,
la suma de todas esas evaluaciones debe ser igual a 1.

Ejemplo: Lanzamiento de un dado.

## Distribución de Probabilidad | Distribución Continua
El resultado de evaluar la función densidad en un punto del soporte
NO  es igual a la probabilidad de que la variable tome ese valor, de hecho, la
probabilidad de que la variable tome un valor individual típicamente es cero. 

La probabilidad de que la variable se encuentre en un rango de valores es la integral
de la función de densidad en ese rango. Además, la integral sobre todo el soporte
debe ser igual a 1.

Ejemplo: Altura de una persona.

## La distribución normal
La distribución normal es muy importante en la teoría estadística, y es 
muy prevalente en las aplicaciones. Una gran cantidad de fenómenos naturales,
al ser medidos, exhiben valores con un comportamiento normal.
```{r, echo=FALSE, fig.height=4}
ggplot(data.frame(x=-300:300/100, y=dnorm(-300:300/100)), aes(x=x, y=y)) + geom_line()
```

## La distribución normal
La distribución normal se caracteriza por su media (mu) y su varianza (sigma^2).
La media es el parámetro de ubicación, nos dice en dónde se concentra la densidad.
La varianza es un parámetro de precisión, nos dice que tan concentrada está la densidad
```{r, echo=FALSE, fig.height=4}
ggplot(data.frame(x=-400:400/100, y=dnorm(-400:400/100)), aes(x=x, y=y)) + geom_line() +
  geom_line(data=data.frame(x=-400:400/100, y=dnorm(-400:400/100, m=2, s=0.3)), color="blue")
```

## La distribución normal | Propiedades
- Es simétrica alrededor de la media (mu)
- La media es igual a la mediana y a la moda
- Cerca del 68% de la distribución se acumula en una desviación estándar alrededor de la media
- Cerca del 95% de la distribución se acumula en dos desviaciónes estándar alrededor de la media

## Ley de los grandes números

## Aprendizaje Estadístico

- El problema de aprendizaje supervisado
- Error = Sesgo + Varianza. Tradeoff
- Overfitting y la maldición de la dimensionalidad
- KISS: Model Edition
- Medición del error (sesgo + varianza)
- Cross Validation. Bootstrap. Out of bag
- Regresión. Métricas de error
- Clasificación. Métricas de error
- Modelos lineales generalizados
- Lasso, ridge, glmnet
- Árboles de decisión. Random Forests
- Máquinas de soporte vectorial



